\section{202009-1 检测点查询}

\subsection{题目背景}

\subsection{问题描述}

\subsection{输入格式}

\subsection{输出格式}

\subsection{样例 1 输入}

\subsection{样例 1 输出}

\subsection{样例解释}

\subsection{评测用例规模与约定}

\subsection{对讲义中代码的点评或纠错}
 
优点：

使用了结构体：通过定义结构体 Checkpoint 来表示检查点的属性，提高了代码的可读性和结构化程度。

封装了函数：通过将计算距离、比较和筛选最近检查点的逻辑封装成了函数 distance、compare 和 $nearest\_checkpoints$，提高了代码的模块化和可维护性。

使用了标准库：通过使用 C++ 标准库中的 sort 函数，简化了对检查点的排序操作。

使用了 Lambda 表达式：在 sort 函数的参数中使用了 Lambda 表达式，提高了代码的简洁性，避免了额外的函数定义。

考虑了相等情况下的排序：在 compare 函数中，当两个检查点距离相等时，按照 ID 递增顺序排序，保证了排序的稳定性。

使用了向量容器：通过使用 vector 容器来存储检查点的信息，方便了对检查点的动态管理，如添加、删除等操作。

代码逻辑清晰：通过适当的命名和结构，代码逻辑相对清晰，易于理解。

缺点和改进空间：

没有进行输入数据的合法性验证：代码没有对输入的数据进行验证，如果输入的数据不符合要求，可能会导致程序运行错误。建议添加输入数据的验证。

没有错误处理：程序没有考虑除数为零的情况，当检查点数量为零时，可能导致计算距离的函数 distance 中的除法出现问题。应该在代码中添加相应的错误处理逻辑。

\subsection{自己原创的代码的点评与注释}

定义结构体DetectionPoint表示检测点，包含编号和坐标信息。

编写计算两点之间距离的函数calculateDistance。

编写比较函数compareDistance，用于sort排序时按距离从小到大排序，如果距离相同，则按编号从小到大排序。

在主函数中，读取输入，存储检测点信息，并使用sort函数对检测点进行排序。

输出距离最近的三个检测点的编号。

\begin{lstlisting}[language=C++]
    #include <iostream>
    #include <vector>
    #include <cmath>
    #include <algorithm>
    
    using namespace std;
    
    // 定义检测点结构体，包含编号和坐标信息
    struct DetectionPoint {
        int id;
        int x;
        int y;
    };
    
    // 计算两点之间的距离
    double calculateDistance(int x1, int y1, int x2, int y2) {
        return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));
    }
    
    // 比较函数，用于sort排序时按距离从小到大排序
    bool compareDistance(const DetectionPoint& a, const DetectionPoint& b, int citizenX, int citizenY) {
        double distanceA = calculateDistance(a.x, a.y, citizenX, citizenY);
        double distanceB = calculateDistance(b.x, b.y, citizenX, citizenY);
    
        // 如果距离相同，按编号从小到大排序
        if (distanceA == distanceB) {
            return a.id < b.id;
        }
    
        return distanceA < distanceB;
    }
    
    int main() {
        // 读取输入
        int n, citizenX, citizenY;
        cin >> n >> citizenX >> citizenY;
    
        // 存储检测点信息的数组
        vector<DetectionPoint> detectionPoints(n);
    
        // 读取每个检测点的坐标信息
        for (int i = 0; i < n; ++i) {
            detectionPoints[i].id = i + 1;
            cin >> detectionPoints[i].x >> detectionPoints[i].y;
        }
    
        // 使用sort函数对检测点进行排序，排序规则为距离从小到大
        sort(detectionPoints.begin(), detectionPoints.end(), [citizenX, citizenY](const DetectionPoint& a, const DetectionPoint& b) {
            return compareDistance(a, b, citizenX, citizenY);
        });
    
        // 输出距离最近的三个检测点的编号
        for (int i = 0; i < min(3, n); ++i) {
            cout << detectionPoints[i].id << endl;
        }
    
        return 0;
    }    
\end{lstlisting}