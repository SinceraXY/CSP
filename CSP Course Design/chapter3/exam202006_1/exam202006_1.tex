\section{202006-1 线性分类器}

\subsection{问题描述}

考虑一个简单的二分类问题——将二维平面上的点分为 A 和 B 两类。
训练数据包含 n 个点，其中第 i 个点 (1 ≤ i ≤ n) 可以表示为一个三元组 (xi
, yi
, typei)，即该点的
横坐标、纵坐标和类别。
在二维平面上, 任意一条直线可以表示为 θ0 + θ1x + θ2y = 0 的形式，即由 θ0、θ1 和 θ2 三个参数
确定该直线，且满足 θ1、θ2 不同时为 0 。
基于这 n 个已知类别的点，我们想要在平面上找到一条直线作为一个线性分类器。具体来说，这
条线要把训练数据中的 A、B 两类点完美分隔开来，即一侧只有 A 类点、另一侧只有 B 类点。这样，
对于任意一个的末知类别的点，我们就可以根据它是位于直线的哪一侧来预测它的类别了。

在本题中我们仅需要处理 m 个如下查询：给定一条直线，判断它是否能将训练数据中的 A、B 两
类点完美分开。
\subsection{输入格式}

从标准输入读入数据。
输入共 n + m + 1 行。
第一行包含用空格分隔的两个正整数 n 和 m，分别表示点和查询的个数。
第二行到第 n+ 1 行依次输入 n 个点的信息。第 i+ 1 行 (1 ≤ i ≤ n) 包含用空格分割的三项 xi、yi、
typei，分别代表第 i 个点的横、纵坐标和类别，其中坐标为整数、类别为一个大写英文字母 A 或 B。
第 n + 2 行到第 n + m + 1 行依次输入 m 个查询。第 j + n + 1 行 (1 ≤ j ≤ m) 包含用空格分隔的
三个整数 θ0、θ1 和 θ2，表示第 j 个查询中给定直线的三个参数。

\subsection{输出格式}

输出到标准输出。
输出共 m 行，每行输出一个字符串。
第 j 行 (1 ≤ j ≤ m) 输出的字符串对应第 j 个查询的结果：如果给定直线可以完美分隔 A、B 两
类点，则输出 Yes；否则输出 No。

\subsection{样例输入}

\begin{lstlisting}[numbers=none]
9 3
1 1 A
1 0 A
1 -1 A
2 2 B
2 3 B
0 1 A
3 1 B
1 3 B
2 0 A
0 2 -3
-3 0 2
-3 1 1
\end{lstlisting}

\subsection{样例输出}

\begin{lstlisting}[numbers=none]
    No
    No
    Yes
\end{lstlisting}

\subsection{样例解释}

如图3.2所示，只有第 3 个查询给出的直线能将 A、B 两类点完美分隔。

\subsection{子任务}

有些测试点具有特殊的性质：前 2 个测试点中不存在任何信号灯。测试点的输入数据规模:前6个测试点保证$n ≤ 10^3$;所有测试点保证$n ≤ 10^5$。

\subsection{对讲义中代码的点评或纠错}
 
清晰明了的逻辑： 代码逻辑相对清晰，容易理解。通过输入点的坐标和类型，然后根据给定的直线参数，判断两组点是否被该直线分开。

使用了C++的标准库： 使用了C++的标准库中的vector和pair，这样可以更方便地管理和操作点集合。

变量命名： 变量命名相对明确，有助于理解代码的功能。

合理利用bool类型： 使用布尔类型来表示条件的真假，提高了代码的可读性。

未处理输入异常： 代码没有对输入进行异常处理。如果输入不符合预期，可能导致程序行为不可预测。建议添加一些输入验证机制，确保程序稳健性。

\subsection{自己原创的代码的点评与注释}

首先读取点的信息，然后根据查询的直线参数判断是否能够完美分隔，并输出结果。

\begin{lstlisting}[language=C++]
    #include <iostream>
    #include <vector>
    
    using namespace std;
    
    // 定义点的结构体
    struct Point {
        int x, y;
        char type;
    };
    
    // 判断点在直线的哪一侧
    int classifyPoint(Point p, int theta0, int theta1, int theta2) {
        int result = theta0 + theta1 * p.x + theta2 * p.y;
        if (result > 0) {
            return 1; // 点在直线上方
        } else {
            return -1; // 点在直线下方或在直线上
        }
    }
    
    // 判断是否能完美分隔A、B两类点
    bool canSeparate(vector<Point>& points, int theta0, int theta1, int theta2) {
        for (Point& p : points) {
            int classification = classifyPoint(p, theta0, theta1, theta2);
            if (classification * (p.type == 'A' ? 1 : -1) <= 0) {
                // 若分类结果与实际类别不一致，则不能完美分隔
                return false;
            }
        }
        return true; // 所有点都正确分类，可以完美分隔
    }
    
    int main() {
        int n, m;
        cin >> n >> m;
    
        // 读取点的信息
        vector<Point> points(n);
        for (int i = 0; i < n; ++i) {
            cin >> points[i].x >> points[i].y >> points[i].type;
        }
    
        // 读取查询的直线参数
        for (int j = 0; j < m; ++j) {
            int theta0, theta1, theta2;
            cin >> theta0 >> theta1 >> theta2;
    
            // 判断是否能完美分隔，并输出结果
            if (canSeparate(points, theta0, theta1, theta2)) {
                cout << "Yes" << endl;
            } else {
                cout << "No" << endl;
            }
        }
    
        return 0;
    }    
\end{lstlisting}