\section{201709-2 公共钥匙盒}

\subsection{题目背景}

\subsection{问题描述}

\subsection{输入格式}

\subsection{输出格式}

\subsection{样例 1 输入}

\subsection{样例 1 输出}

\subsection{样例解释}

\subsection{评测用例规模与约定}

\subsection{对讲义中代码的点评或纠错}
 
优点：

使用了结构体：通过定义结构体 Event 来表示事件，包含时间、类型和事件id，提高了代码的可读性和结构化程度。

使用了优先队列：通过使用$ priority\_queue $来存储事件，按照时间和事件类型进行排序，实现了按时间顺序处理事件的功能，提高了代码的简洁性和效率。

使用了算法库：通过使用 <algorithm> 头文件中的 find 函数，实现了在向量中查找元素的操作，提高了代码的简洁性和可读性。

使用了结构体的比较函数：通过在结构体中重载 < 运算符，实现了对事件的自定义排序，确保按照时间、类型和id的顺序进行排序。

代码逻辑清晰：通过优先队列的方式，按照事件发生的时间顺序依次处理，代码逻辑相对清晰，易于理解。

考虑了钥匙的状态：在处理事件时，根据事件的类型，更新了钥匙盒的状态，使得钥匙的状态符合事件的影响。

\subsection{自己原创的代码的点评与注释}

使用结构体Teacher存储老师的信息，包括钥匙编号、开始上课时间和上课时长。

创建一个时间线数组，记录每个时刻每个挂钩上的钥匙编号。正数表示老师取钥匙，负数表示老师还钥匙。

模拟老师取还钥匙的过程，根据时间线更新每个挂钩上的钥匙编号。

输出最终钥匙盒里的钥匙顺序。

\begin{lstlisting}[language=C++]
    #include <iostream>
    #include <vector>
    #include <algorithm>
    
    using namespace std;
    
    // 定义老师的结构体，包含钥匙编号、开始上课时间和上课时长
    struct Teacher {
        int keyNumber;
        int startTime;
        int duration;
    };
    
    int main() {
        // 读取输入数据
        int N, K;
        cin >> N >> K;
    
        // 创建老师数组，用于存储老师的信息
        vector<Teacher> teachers(K);
    
        // 读取每位老师的信息
        for (int i = 0; i < K; ++i) {
            cin >> teachers[i].keyNumber >> teachers[i].startTime >> teachers[i].duration;
        }
    
        // 创建时间线数组，用于记录每个时刻每个挂钩上的钥匙编号
        vector<vector<int>> timeline(2 * K + 1, vector<int>(N + 1, 0));
    
        // 处理每位老师的信息
        for (int i = 0; i < K; ++i) {
            int key = teachers[i].keyNumber;  // 获取钥匙编号
            int start = teachers[i].startTime;  // 获取开始上课时间
            int end = start + teachers[i].duration;  // 计算结束上课时间
    
            // 在时间线上标记老师取钥匙和还钥匙的时刻
            timeline[start][key] = i + 1;  // 正数表示取钥匙
            timeline[end][key] = -(i + 1);  // 负数表示还钥匙
        }
    
        // 创建一个数组用于记录每个挂钩上的当前钥匙编号
        vector<int> keyOrder(N + 1);
    
        // 遍历时间线，模拟老师取还钥匙的过程
        for (int i = 1; i <= 2 * K; ++i) {
            for (int j = 1; j <= N; ++j) {
                int action = timeline[i][j];
                if (action > 0) {
                    // 老师取钥匙
                    keyOrder.push_back(j);
                } else if (action < 0) {
                    // 老师还钥匙
                    keyOrder.erase(remove(keyOrder.begin(), keyOrder.end(), -action), keyOrder.end());
                }
            }
        }
    
        // 输出最终钥匙盒里的钥匙顺序
        for (int i = 0; i < N; ++i) {
            cout << keyOrder[i] << " ";
        }
    
        return 0;
    }    
\end{lstlisting}

\subsection{你推荐的代码}

\href{201709-2 公共钥匙盒}{https://blog.csdn.net/weixin\_44572229/article/details/122595406}

\subsection{网上的代码}
\begin{lstlisting}[language=C++]
    #include<iostream>
    #include<algorithm>
    using namespace std;
    const int N=1000;
    struct Node{
        int no;//钥匙编号
        int t;//时间
        int type;//状态 0借  1还
        bool operator<(const Node &a)const 
        {  //按时间从小到大排序 ,如果时间相同，再按照钥匙编号由小到大排序 
            return (t==a.t)?(no<a.no):(t<a.t);
         } 
    }a[2*N];
    int main()
    {
        int n,k,w,s,c,m=0,i,j;
        int ans[N+1];//ans模拟钥匙盒,ans[i]=0表示此位置为空 
        cin>>n>>k;
        for(i=1;i<=n;i++)
          ans[i]=i;//初始化 
        while(k--){
            cin>>w>>s>>c;
            a[m].no=w;
            a[m].t=s;
            a[m++].type=0;//借
            a[m].no=w;
            a[m].t=s+c;
            a[m++].type=1;//还 
        }
        sort(a,a+m);
        for(i=0;i<m;i=j){//i=j是为了保证 i=下个一时间 
            for(j=i;j<m&&a[j].t==a[i].t;j++);
    //先处理同一时间还钥匙 ，编号小的优先还 ，由于时间相同，钥匙编号由小到大排序 故顺序处理即可 
            for(int t=i;t<j;t++)
              if(a[t].type==1){
                  int pos;
                  for(pos=1;pos<=n&&ans[pos];pos++);
                  ans[pos]=a[t].no;
              } 
            // 处理同一时间借钥匙 
            for(int t=i;t<j;t++)
                if(a[t].type==0){
                    int no=a[t].no;
                    int pos;
                    for(pos=1;pos<=n;pos++)//找到要借的钥匙的位置，并标记为借走 
                      if(ans[pos]==no){
                          ans[pos]=0;
                          break;
                      }
                }
        }
        for(i=1;i<=n;i++)
          cout<<ans[i]<<" ";
        cout<<endl;
        return 0; 
    }
\end{lstlisting}